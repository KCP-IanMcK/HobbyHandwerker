# Penetrationstest-Report HobbyHandwerker

**Ziel:** Webanwendung HobbyHandwerker (Hobby-Verleih-Plattform)  
**Testart:** Whitebox & Blackbox  
**Methodik:** OWASP ASVS 5.0.0, OWASP Top 10 2025  
**Datum:** 28. Januar 2026  
**Tester:** Sunny Känel

---

## Zusammenfassung

Im Rahmen der Phase 2 Sicherheitsbewertung von HobbyHandwerker haben wir eine umfassende Analyse der Webanwendung durchgeführt. Dabei wurden **13 Schwachstellen identifiziert**, davon 4 mit kritischem Schweregrad.

**Wichtigste Erkenntnisse:**

- **4 kritische Schwachstellen** (F1, F2, F3, F9): Ermöglichen direkten Datenbankzugriff, Passwort-Exposition, Zugriff auf fremde Daten und Rechteausweitung
- **9 mittelschwere Schwachstellen** (F4, F5, F6, F7, F8, F10, F11, F12, F13): Fehlende Input-Validierung, kein Account-Lockout, keine Token-Revokation, SQL-Injection-Anfälligkeit, Docker-Konfiguration, Datenbankzugriff, Test-Passwörter
- **Positive Aspekte:** CORS korrekt konfiguriert, Passwörter mit BCrypt gehasht, Dependencies aktuell, Error Handling sicher

Die kritischsten Probleme müssen sofort behoben werden, da sie vollständigen Zugriff auf Benutzerdaten und die Datenbank ermöglichen.

---

## Einführung

HobbyHandwerker ist eine Webanwendung mit Angular 19 (TypeScript) Frontend und Spring Boot 3.5.4 (Java) Backend, die auf MySQL/MariaDB läuft.

**Getestete Bereiche:**
- Authentifizierung & Autorisierung
- Session Management & Token Handling
- Eingabevalidierung & Output Encoding
- Datenbankzugriffe & SQL-Injection-Schutz
- Secrets Management & Konfiguration
- Docker-Konfiguration & Deployment-Sicherheit
- Datenbank-Initialisierung & Test-Daten

**Nicht getestete Bereiche (aufgrund mangelnder Relevanz für Lernprojekt):**
- Build-Konfigurationen (angular.json, tsconfig, karma.conf.js)
- Statische Assets (public/)
- Dependency-Scanning mit automatisierten Tools (npm audit, mvn dependency:check) - bereits durch aktuelle Versionen abgedeckt

**Tools & Methodik:**
- PowerShell Invoke-WebRequest für API-Tests
- Statische Code-Analyse (SAST) aller Java/TypeScript-Dateien
- Dynamische Anwendungstests (DAST) mit echten HTTP-Requests
- Manuelle Reproduktion kritischer Findings direkt über das Frontend (Login, Benutzer-Verwaltung, Profil-Verwaltung)

**Getestete Sicherheits-Aspekte:**
- **Zugriffskontrolle:** Können normale Benutzer auf fremde Daten zugreifen? → JA (F3, F2)
- **Credential Management:** Sind Zugangsdaten sicher gespeichert? → NEIN (F1, F2)
- **API-Sicherheit:** Sind die Endpunkte gegen Missbrauch geschützt? → NEIN (F3, F4, F5)
- **Privilege Escalation:** Können Benutzer ihre Privilegien selbst erhöhen? → JA (F9)
- **Brute-Force-Schutz:** Gibt es Schutz vor wiederholten Login-Versuchen? → NEIN (F6)
- **Session-Management:** Können Sessions wirklich beendet werden? → NEIN (F7, F8)
- **Infrastructure Security:** Ist die Docker/Datenbank-Konfiguration sicher? → NEIN (F10, F11, F12, F13)

---

## Methodik

Der Penetrationstest folgte einem strukturierten Zwei-Phase-Ansatz:

### Phase 1: Statische Code-Analyse (SAST)

Manuelle Analyse aller relevanten Quellcode-Dateien (Backend: Java/Spring Boot, Frontend: Angular/TypeScript, Konfigurationen: Docker, SQL, Properties) mit Fokus auf sichere Coding Practices, Secrets Management, Autorisierungslogik und Input-Validierung.

### Phase 2: Dynamische Anwendungstests (DAST) + Manuelle Verifikation

Tests der laufenden Anwendung via REST-API (PowerShell Invoke-WebRequest) und direkte Frontend-Interaktion (Browser, Login, Benutzer-Verwaltung). Kritische Findings wurden manuell reproduziert über das UI.

---

## Festgestellte Schwachstellen

### F1: Hardcodierte Datenbank-Zugangsdaten

| **Schweregrad** | **OWASP Top 10** | **OWASP ASVS** |
|---|---|---|
| KRITISCH | A02: Cryptographic Failures | 6.1 |

**Was haben wir gefunden?**

In der Datei `DataSourceFactory.java` (Zeilen 27-35) sind die Datenbank-Zugangsdaten direkt im Quellcode hinterlegt. Username `admin` und Passwort `mariadb-pw-123` werden als einfache Strings definiert:

```java
dataSource.setUser("admin");
dataSource.setPassword("mariadb-pw-123");
```

**Warum ist das ein Problem?**

Diese Praxis wird "Hardcoding" genannt und ist ein kritischer Sicherheitsverstoß. Quellcode landet an vielen Orten: Git-Repositories, Backups, CI/CD-Pipelines, Entwickler-Laptops. Jede Person mit Zugriff auf den Code erhält automatisch Datenbankzugriff. Bei HobbyHandwerker bedeutet das: Alle 9+ Benutzerprofile, E-Mails und Passwort-Hashes sind kompromittiert.

**Risiko:**

Ein Angreifer mit Quellcode-Zugriff kann sich direkt zur MySQL-Datenbank verbinden und:
- Alle Benutzerdaten exportieren
- Datenbank-Inhalte manipulieren
- Komplette Datenbank löschen (Ransomware)
- Persistenter Zugriff (Backdoor)

**Empfehlung:**

Verwenden Sie Umgebungsvariablen oder Secrets-Management-Systeme zur Laufzeit, nicht im Code.

---

### F2: Benutzer-Passwort in API-Responses exponiert

| **Schweregrad** | **OWASP Top 10** | **OWASP ASVS** |
|---|---|---|
| KRITISCH | A01: Broken Access Control | 8.3 |

**Was haben wir gefunden?**

Die User-Klasse in `User.java` serialisiert das Passwort-Feld in JSON-API-Responses. Beim Abruf von Benutzer-Daten via `GET /user/2` werden das BCrypt-Hash des Passworts zurückgesendet:

```json
{
  "id_user": 2,
  "username": "dummy2",
  "email": "dummy2@mail.de",
  "password": "$2a$10$7JwP6CFRoCVEeh2JX9B6eOHSd/BS57RINj68eXEj8pXYwSrDaA9m2",
  "role": 2
}
```

**Warum ist das ein Problem?**

Passwort-Hashes sollten niemals in API-Responses übertragen werden. Ein Angreifer kann:
1. Netzwerkverkehr abfangen (Man-in-the-Middle, öffentliches WiFi)
2. Den BCrypt-Hash offline mit GPU-beschleunigtem Brute-Force knacken
3. Das Passwort für andere Konten des Benutzers verwenden (Passwort-Wiederverwendung)

Dies wurde sowohl via direkter API als auch via Frontend-Login verifiziert.

**Risiko:**

- Alle BCrypt-Hashes in Responses sichtbar
- Offline-Cracking möglich (GPU-beschleunigt)
- Multi-Account-Kompromittierung
- Verletzung von GDPR/Datenschutz-Anforderungen

**Empfehlung:**

Passwörter sollten niemals in JSON-Responses serialisiert werden. Verwenden Sie `@JsonIgnore`-Annotationen oder Data Transfer Objects (DTOs), die nur relevante Felder zurückgeben.

---

### F3: Broken Access Control - Normale Benutzer sehen alle Accounts

| **Schweregrad** | **OWASP Top 10** | **OWASP ASVS** |
|---|---|---|
| KRITISCH | A01: Broken Access Control | 4.1 |

**Was haben wir gefunden?**

Der Endpunkt `GET /user/all` erlaubt es normalen Benutzern (role=1), eine Liste aller Benutzer-Accounts inklusive E-Mail-Adressen abzurufen. Dies ist offenbar als Admin-Funktion gedacht, ist aber auch für normale User zugänglich.

**Warum ist das ein Problem?**

Normale Benutzer sollten nicht sehen, welche anderen Benutzer im System existieren. Dies ermöglicht:
- User-Enumeration (alle Accounts aufzählen)
- E-Mail-Harvesting für Phishing-Kampagnen
- Kombiniert mit F2: Alle Passwort-Hashes sichtbar
- Targeting spezifischer Benutzer für Angriffe

**Risiko:**

- Komplette Benutzerlisten-Offenlegung
- E-Mail-Adressen für externe Phishing-Kampagnen
- Combined mit F2: Passwort-Hashes aller Benutzer
- Personalisierte Angriffe möglich

**Empfehlung:**

Implementieren Sie strenge Autorisierungsprüfungen. Der Endpunkt sollte nur Administratoren zur Verfügung stehen. Normale Benutzer sollten nur ihre eigenen Daten abrufen können.

---

### F4: SQL Injection via Statement statt PreparedStatement

| **Schweregrad** | **OWASP Top 10** | **OWASP ASVS** |
|---|---|---|
| MITTEL | A03: Injection | 5.3 |

**Was haben wir gefunden?**

In `UserDao.java` wird die `select(int id)`-Methode mit einem einfachen `Statement` implementiert, bei dem die User-ID direkt in den SQL-String konkateniert wird:

```java
Statement stmt = connection.createStatement();
String query = "SELECT * FROM users WHERE id_user = " + id;
```

Die sichere Methode (`login()`) nutzt korrekt `PreparedStatement` mit Paramter-Binding.

**Warum ist das ein Problem?**

Obwohl diese spezifische Stelle mit Integer-ID schwer zu exploiten ist, zeigt es eine sicherheitskritische Coding-Praxis. Wenn später weitere Parameter hinzugefügt werden, könnte dies zu SQL Injection führen.

**Risiko:**

- SQL Injection möglich (mit speziellen Payloads)
- Datenbank-Offenlegung
- Unbefugter Daten-Zugriff/-Manipulation

**Empfehlung:**

Immer `PreparedStatement` mit Parameter-Binding verwenden, nie String-Konkatenation für SQL-Queries.

---

### F5: Keine Input-Validierung bei Benutzerregistrierung

| **Schweregrad** | **OWASP Top 10** | **OWASP ASVS** |
|---|---|---|
| MITTEL | A05: Security Misconfiguration | 5.1 |

**Was haben wir gefunden?**

Der Registrierungs-Endpunkt `POST /user` akzeptiert beliebige Eingaben ohne Validierung. Ein Benutzer kann sich mit dem Username `test_img_onerror` registrieren - ein XSS-Payload, der in HTML-Kontexten ausgeführt werden könnte.

Auch die Passwort-Länge ist nicht limitiert. Ein Passwort kann 1 Zeichen oder 10.000 Zeichen lang sein.

**Warum ist das ein Problem?**

Fehlende Input-Validierung führt zu:
- Potenziellen XSS-Angriffen (wenn Usernames ungescaped angezeigt werden)
- Datenqualitäts-Problemen
- Buffer-Overflow-Risiken bei extremen Eingaben
- Ermöglichung von Account-Enumeration (Duplikate zeigen, ob User existiert)

**Risiko:**

- XSS via Benutzernamen (wenn ungescaped angezeigt)
- Unerwartete Anwendungs-Fehler durch extreme Eingaben
- Datenbank-Speicherprobleme

**Empfehlung:**

Implementieren Sie Validierungsregeln: Benutzernamen sollten Länge/Format-Vorgaben erfüllen, Passwörter Mindestanforderungen.

---

### F6: Keine Account-Lockout bei wiederholten fehlgeschlagenen Login-Versuchen

| **Schweregrad** | **OWASP Top 10** | **OWASP ASVS** |
|---|---|---|
| MITTEL | A07: Identification & Authentication Failures | 3.4 |

**Was haben wir gefunden?**

Der Login-Endpunkt `PUT /user/login` hat kein Rate-Limiting oder Account-Lockout-Mechanismus. Ein Angreifer kann beliebig lange Passwörter durchprobieren, ohne dass das Konto gesperrt wird.

**Warum ist das ein Problem?**

Ohne Account-Lockout sind Brute-Force-Angriffe auf Benutzerkonten möglich. Mit modernen GPU-Beschleunigung können Millionen von Passwort-Kombinationen pro Sekunde versucht werden. Schwache Passwörter könnten in Sekunden geknackt werden.

**Risiko:**

- Brute-Force-Angriffe auf Konten möglich
- Schwache Passwörter schnell geknackt
- Account-Übernahmen durch Passwort-Guessing

**Empfehlung:**

Implementieren Sie Account-Lockout nach 5-10 fehlgeschlagenen Versuchen mit temporärer Sperrung (15-30 Minuten).

---

### F7: Keine Token-Revokation (Logout nicht implementiert)

| **Schweregrad** | **OWASP Top 10** | **OWASP ASVS** |
|---|---|---|
| MITTEL | A07: Identification & Authentication Failures | 3.5 |

**Was haben wir gefunden?**

Es gibt keinen Logout-Endpunkt und keinen Mechanismus zur Revokation von JWT-Tokens. Ein ausgegebener Token bleibt bis zu seinem Ablauf (1 Stunde) gültig, auch wenn der Benutzer versucht zu "logout".

**Warum ist das ein Problem?**

JWT-Tokens sind selbst-validierend und erfordern normalerweise eine Blacklist-Datenbank zur Revokation. Ohne diesen Mechanismus:
- Benutzer können nicht sofort abgemeldet werden
- Gestohlene Tokens bleiben 1 Stunde lang gültig
- Unerwünschte Sessions können nicht beendet werden
- Incident-Response unmöglich (schnelle Isolation)

**Risiko:**

- Gestohlene Tokens verwertbar für volle 1 Stunde
- Keine Möglichkeit, aktive Sessions zu unterbrechen
- Längere Angriffsfenster bei Kompromittierung

**Empfehlung:**

Implementieren Sie einen Token-Blacklist-Mechanismus und einen Logout-Endpunkt, der Tokens invalidiert.

---

### F10: Docker-Image mit `mariadb:latest` (keine feste Version)

| **Schweregrad** | **OWASP Top 10** | **OWASP ASVS** |
|---|---|---|
| MITTEL | A06: Vulnerable Components | 8.4 |

**Was haben wir gefunden?**

Das Dockerfile verwendet `FROM mariadb:latest` ohne eine feste Version anzugeben:

```dockerfile
FROM mariadb:latest
COPY init.sql /docker-entrypoint-initdb.d/
```

**Warum ist das ein Problem?**

"Latest" ist ein Moving Target. Mit jedem Docker-Pull könnte eine neue, unterschiedliche Version heruntergeladen werden. Dies führt zu:
- **Reproduzierungsproblemen:** Unterschiedliche Versionen auf verschiedenen Entwickler-Computern
- **Unerwartete Breaking Changes:** Neue MariaDB-Versionen könnten inkompatible SQL-Syntax verwenden
- **Sicherheits-Lücken:** Eine neue Version könnte anfänglich Bugs oder Sicherheitsprobleme enthalten, die später gefixt werden

**Risiko:**
- Inkonsistente Umgebungen zwischen Developern
- Unerwartete Fehler in Production
- Schwierigere Debugging und Support

**Empfehlung:**

Verwenden Sie eine feste, getestete Version:
```dockerfile
FROM mariadb:11.4.2-jammy
```

---

### F11: Datenbank-Port 3306 nach außen exposed

| **Schweregrad** | **OWASP Top 10** | **OWASP ASVS** |
|---|---|---|
| MITTEL | A05: Security Misconfiguration | 8.1 |

**Was haben wir gefunden?**

In der docker-compose.yml wird Port 3306 nach außen freigegeben:

```yaml
ports:
  - "3306:3306"
```

**Warum ist das ein Problem?**

Dies bedeutet, dass die MySQL-Datenbank von außerhalb des Docker-Containers erreichbar ist. Jemand im gleichen Netzwerk (oder Internet, wenn Port-Forwarding aktiv ist) kann versuchen, sich direkt zur Datenbank zu verbinden. Kombiniert mit F1 (hardcodierte Credentials) ist dies kritisch.

**Risiko:**
- Direkter Datenbankzugriff von außen möglich
- Kombiniert mit F1: Admin-Zugangsdaten nutzbar
- Für lokale Entwicklung nicht nötig

**Empfehlung:**

Für lokale Entwicklung: Port nicht exponieren oder nur auf localhost limitieren:
```yaml
ports:
  - "127.0.0.1:3306:3306"
```

Für Production: Port überhaupt nicht exponieren, nur interne Docker-Netzwerk-Kommunikation.

---

### F12: Test-Passwörter in SQL-Init-Kommentar dokumentiert

| **Schweregrad** | **OWASP Top 10** | **OWASP ASVS** |
|---|---|---|
| MITTEL | A02: Cryptographic Failures | 2.3 |

**Was haben wir gefunden?**

In init.sql gibt es einen Kommentar, der die Test-Passwörter der Dummy-Konten offenlegt:

```sql
-- Insert dummy users
-- PWs dummy2: pass2, dummy3: pass3 etc.
INSERT INTO `user` ...
```

**Warum ist das ein Problem?**

Diese Kommentare sollten niemals in produktivem Code stehen. Jemand mit Zugriff auf die Datei (Git-Repository, Backups, Code-Review) kennt sofort die Test-Passwörter. Dies ist besonders problematisch, weil:
- Die BCrypt-Hashes der Dummy-Accounts in der Datenbank bleiben
- Falls die Passwörter nicht geändert werden, sind die Konten leicht zu kompromittieren
- Es zeigt schlechte Security-Practices

**Risiko:**
- Test-Passwörter sind dokumentiert
- Dummy-Accounts mit bekannten Credentials bleiben in Production
- Leichte Enumeration von Test-Konten

**Empfehlung:**

Entfernen Sie die Passwort-Kommentare vollständig. Wenn Test-Accounts nötig sind, sollten diese mit zufälligen, sicheren Passwörtern erstellt werden und als separate Datei (`test-data-REMOVE-IN-PRODUCTION.sql`) gekennzeichnet werden.

---

### F13: Dummy-Konten mit bekannten BCrypt-Hashes verbleiben in Datenbank

| **Schweregrad** | **OWASP Top 10** | **OWASP ASVS** |
|---|---|---|
| MITTEL | A07: Identification & Authentication Failures | 2.1 |

**Was haben wir gefunden?**

Die init.sql erstellt fünf Dummy-Benutzerkonten (visitor, dummy2-5) mit festen BCrypt-Hashes, die jedes Mal bei der Datenbank-Initialisierung eingefügt werden:

```sql
INSERT INTO `user` VALUES
(1, 'visitor', 'visitor', '$2a$10$O.U1IL1sMlySGk...', 1),
(2, 'dummy2@mail.de', 'dummy2', '$2a$10$EL0niT/fWpcKBLaSUvh0bOUB6bBAwZW2...', 2),
...
```

**Warum ist das ein Problem?**

Dummy-Konten sollten nicht in Production-Datenbanken vorhanden sein. Diese Konten:
- Können von Testbenutzern versehentlich verwendet werden
- Haben vorhersehbare E-Mail-Adressen und Benutzernamen
- Ihre Passwörter sind in mehreren Kopien der init.sql dokumentiert
- Können für Penetrationstests oder unbefugte Zugriffe missbraucht werden

**Risiko:**
- Unbefugte Login-Versuche mit bekannten Konten möglich
- Test-Daten in Production vermischt mit echten Daten
- Sicherheitsaudits zeigen schlechte Praktiken

**Empfehlung:**

Teilen Sie SQL-Scripts in Production-Data und Test-Data:
- `init.sql`: Nur echte Produktivdaten und Schema
- `test-data.sql`: Nur zum Testen, wird in Production nicht verwendet

---

### F8: JWT Token mit 1 Stunde Gültigkeit (zu lange)

| **Schweregrad** | **OWASP Top 10** | **OWASP ASVS** |
|---|---|---|
| MITTEL | A07: Identification & Authentication Failures | 3.3 |

**Was haben wir gefunden?**

JWT-Tokens werden mit einer Gültigkeit von 3600 Sekunden (1 Stunde) ausgegeben. Dies ist länger als bei modernen Best Practices üblich.

**Warum ist das ein Problem?**

Eine Gültigkeitsdauer von 1 Stunde bedeutet:
- Wenn ein Token gestohlen wird, hat der Angreifer 60 Minuten Zeit, bevor es automatisch ungültig wird
- Benutzer könnten lange Zeit unbewusst kompromittiert sein
- Zu lange Zeitfenster für Angriffe
- Schlecht für hochsensible Operationen

**Risiko:**

- Langes Angriffsfenster bei Token-Diebstahl
- Verzögerte Erkennung von Kompromittierungen
- Benutzer können lange Zeit missbraucht werden

**Empfehlung:**

Reduzieren Sie die Token-Gültigkeit auf 15-30 Minuten und implementieren Sie Refresh-Tokens für längerfristige Sessions. Kombiniert mit F7 (Token-Revokation).

---

### F9: Privilege Escalation - Benutzer können ihre Rolle ändern

| **Schweregrad** | **OWASP Top 10** | **OWASP ASVS** |
|---|---|---|
| KRITISCH | A01: Broken Access Control | 4.2 |

**Was haben wir gefunden?**

Der Update-Endpunkt `PUT /user/{id}` akzeptiert das `role`-Feld in der Request und aktualisiert es ohne Autorisierungsprüfung. Ein normaler Benutzer (role=1) kann einen PUT-Request mit `role=3` senden und sich selbst zu Admin erhöhen:

```json
PUT /user/2
{
  "id_user": 2,
  "username": "attacker",
  "email": "attacker@mail.com",
  "password": "newpass",
  "role": 3
}
```

Response: 200 OK - Rolle erfolgreich auf 3 geändert.

**Warum ist das ein Problem?**

Dies ist eine direkte Privilege-Escalation-Schwachstelle. Ein normaler Benutzer kann sich selbst zu Admin-Rechten erhöhen und damit:
- Auf Admin-Funktionen zugreifen
- Alle anderen Benutzer manipulieren
- Vollständigen Datenbankzugriff erlangen (kombiniert mit F1)

**Risiko:**

- Sofortige Privilege-Escalation zu Admin-Rechten
- Angreifer erhält vollständigen Anwendungszugriff
- Kombiniert mit F1: Direkter Datenbankzugriff
- Account-Übernahme aller anderen Benutzer möglich

**Empfehlung:**

Implementieren Sie strikte Autorisierungsprüfungen. Das `role`-Feld sollte niemals vom Client aktualisierbar sein. Nur Administratoren sollten Rollen ändern können, und auch dann mit zusätzlichen Validierungen.

---

## Positiv umgesetzte Sicherheitsmaßnahmen

Neben den Schwachstellen gibt es auch mehrere Aspekte, die korrekt implementiert wurden:

**CORS richtig konfiguriert:** Die Anwendung akzeptiert nur Requests von `localhost:4200`. Dies verhindert, dass bösartige Websites im Namen des Benutzers API-Requests stellen.

**Passwörter mit BCrypt gehasht:** Benutzer-Passwörter werden mit BCrypt (Cost-Faktor 10) gehasht, nicht mit einfachen Hash-Funktionen. Dies macht Brute-Force-Angriffe um Größenordnungen langsamer.

**Error Handling sicher:** Fehlermeldungen geben keine Stack Traces oder sensiblen Informationen preis. Ungültige Requests führen zu generischen `400 BadRequest`-Antworten.

**Dependencies aktuell:** Spring Boot 3.5.4 und jjwt 0.11.5 sind aktuelle Versionen ohne bekannte CVEs.

---

## Fazit

Der Penetrationstest von HobbyHandwerker identifizierte **13 Schwachstellen**, davon 4 mit kritischem Schweregrad. Die kritischsten Probleme (F1, F2, F3, F9) ermöglichen direkten Datenbankzugriff und vollständige Anwendungs-Kompromittierung.

Obwohl die Anwendung solide Grundlagen in sicherer Softwareentwicklung zeigt (CORS, BCrypt, Error Handling), bestehen erhebliche Lücken in Authentifizierung, Autorisierung und Secrets Management.

Eine sofortige Behebung der kritischen Schwachstellen wird dringend empfohlen, gefolgt von einer Überprüfung der mittelschweren Probleme.

